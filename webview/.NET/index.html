<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DDV - HelloWorld</title>
  <link rel="stylesheet" href="ddv/ddv.css">
  <script src="ddv/ddv.js"></script>
</head>
<style>
  html,body {
    width: 100%;
    height: 100%;
    margin:0;
    padding:0;
    overscroll-behavior-y: none;
    overflow: hidden;
  }

  #container {
    width: 100%;
    height: 100%;
  }
</style>
<body>
  <div id="container"></div>
</body>
<script>
  // call .net
  // Unified function to send messages to .NET
  function sendMessageToDotNet(message) {
    try { 
      message = (messageType === '') ? message : `${messageType}|${message}`;
      if (window.chrome && window.chrome.webview) {
        // For WinForms and WPF (WebView2)
        window.chrome.webview.postMessage(message);
      }
      else if (window.DotNet) {
        // For Blazor, not sure if this is the right way
        DotNet.invokeMethodAsync(blazorAppName, blazorCallbackName, message);
      }
      else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.webwindowinterop) {
        // iOS and MacCatalyst WKWebView
        window.webkit.messageHandlers.webwindowinterop.postMessage(message);
      }
      else if (hybridWebViewHost){
        // Android WebView
        hybridWebViewHost.sendMessage(message);
      }
      else {
        console.error("Unsupported platform or WebView environment.");
      }
    }
    catch (error) {
      console.error("Error sending message to .NET:", error);
    }
  };

  window.addEventListener("load", function () {
    const message = {
      name: 'load'
    }
    messageType = '__RawMessage';
    console.log(message);
    sendMessageToDotNet(JSON.stringify([message, "true"]));
  });
  // call .net

  // call from .net
  var productkey;
  var messageType;
  let editViewer;
  let browseViewer;
  async function initView(options) {
    console.log(options);
    let name = '';
    try {
      const op = JSON.parse(options);
      console.log(op.productKey);
      productkey = op.productKey;
      name = op.name;
      messageType = op.messageType;
    }
    catch (error) {
      console.log(error);
    }

    // Public trial license which is valid for 24 hours
    // You can request a 30-day trial key from https://www.dynamsoft.com/customer/license/trialLicense/?product=mwc
    Dynamsoft.DDV.Core.license = productkey ?? "DLS2eyJoYW5kc2hha2VDb2RlIjoiMTAwMjI3NzYzLVRYbFFjbTlxIiwibWFpblNlcnZlclVSTCI6Imh0dHBzOi8vbWx0cy5keW5hbXNvZnQuY29tIiwib3JnYW5pemF0aW9uSUQiOiIxMDAyMjc3NjMiLCJzdGFuZGJ5U2VydmVyVVJMIjoiaHR0cHM6Ly9zbHRzLmR5bmFtc29mdC5jb20iLCJjaGVja0NvZGUiOjE4OTc4MDUzNDV9";
    // Preload DDV Resource
    Dynamsoft.DDV.Core.loadWasm();
    await Dynamsoft.DDV.Core.init();
    Dynamsoft.DDV.setProcessingHandler("imageFilter", new Dynamsoft.DDV.ImageFilter());
    let groupUid = "uniqueGroupId";
    const config = {
      type: Dynamsoft.DDV.Elements.Layout,
      flexDirection: "column",
      className: "ddv-edit-viewer-mobile",
      children: [
        {
          type: Dynamsoft.DDV.Elements.Layout,
          className: "ddv-edit-viewer-header-mobile",
          children: [
            {
              // Add a "Back" buttom to header and bind click event to go back to the perspective viewer
              // The event will be registered later.
              type: Dynamsoft.DDV.Elements.Button,
              className: "ddv-button-back",
              events:{
                click: "back"
              }
            },
            Dynamsoft.DDV.Elements.Pagination
          ],
        },
        Dynamsoft.DDV.Elements.MainView,
        {
          type: Dynamsoft.DDV.Elements.Layout,
          className: "ddv-edit-viewer-footer-mobile",
          children: [
            Dynamsoft.DDV.Elements.DisplayMode,
            Dynamsoft.DDV.Elements.RotateLeft,
            Dynamsoft.DDV.Elements.Crop,
            Dynamsoft.DDV.Elements.Filter,
            Dynamsoft.DDV.Elements.Undo,
            Dynamsoft.DDV.Elements.Delete,
            Dynamsoft.DDV.Elements.Load,
          ],
        },
      ],
    };
    editViewer = new Dynamsoft.DDV.EditViewer({
      groupUid: groupUid,
      container: "container",
      uiConfig: config,
    });
    browseViewer = new Dynamsoft.DDV.BrowseViewer({
      groupUid: groupUid,
      container: "container"
    });
    editViewer.hide();
    browseViewer.show();
    editViewer.on("back",() => {
      hideEditor();
    });
    // send back to .net
    const result = [{
      name: name,
    }, location.origin]
    sendMessageToDotNet(JSON.stringify(result));
  }

  function showEditor(){
    browseViewer.hide();
    editViewer.show();
  }

  function hideEditor(){
    editViewer.hide();
    browseViewer.show();
  }

  function createNewDocument() {
    editViewer.closeDocument();
    let doc = Dynamsoft.DDV.documentManager.createDocument();
    editViewer.openDocument(doc.uid);
  }

  function base64toBlob(base64Data, contentType = '', sliceSize = 512) {
    const byteCharacters = atob(base64Data);
    const byteArrays = [];

    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);

      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }

      const byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }

    const blob = new Blob(byteArrays, { type: contentType });
    return blob;
  }

  async function loadImage(base64Image) {
    try {
      if (editViewer) {
        let doc = makesureDocOpened();
        await doc.loadSource(base64toBlob(base64Image));
      }
    } catch (error) {
      console.error('Error loading document:', error);
    } finally {
    }
  }

  async function loadDocument(url, callback) {
    console.log(url);
    
    try {
      const response = await fetch(url, {
        method: "GET"
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const image = await response.arrayBuffer();
      if (editViewer) {
        let doc = makesureDocOpened();
        await doc.loadSource(new Blob([image], { type: response.headers.get("content-type") }));
      }
    } catch (error) {
      console.error('Error loading document:', error);
    } finally {
      // send back to .net
      sendMessageToDotNet(callback);
    }
  }

  function stringToBase64(str) {
    return btoa(unescape(encodeURIComponent(str)));
  };

  async function fileToBase64 (file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]); // Extract Base64 part
      reader.onerror = (error) => reject(error);
      reader.readAsDataURL(file);
    });
    };

  async function onClickSaveToPdf() {
    const result = await savetopdfInner();
    result[0].name = onClickSaveToPdf.name; // call from js, so the name is the function name
    sendMessageToDotNet(JSON.stringify(result));
  }

  async function saveToPdf(name) {
    const result = await savetopdfInner();
    result[0].name = name; // call from .net, the name is the different for .net code to receive result
    sendMessageToDotNet(JSON.stringify(result));
  }

  async function savetopdfInner() {
    let message = {
      name: ''
    };
    let result = "";
    try {
      let response = await saveAsPdf();
      if (!response && Dynamsoft.DDV.lastError) {
        response = Dynamsoft.DDV.lastError.cause;
      }
      if (response instanceof Blob) {
        result = await fileToBase64(response);
      }
      else {
        message.cause = response;
      }
    }
    catch (error) {
      let response = error.cause ?? JSON.stringify(error, Object.getOwnPropertyNames(error));
      message.cause = response;
    }

    return [message, result];
  }


  // call from .net

function makesureDocOpened() {
  let doc = editViewer.currentDocument;
  if (!doc) {
    doc = Dynamsoft.DDV.documentManager.createDocument();
    editViewer.openDocument(doc.uid);
  }
  return doc;
}

function rotateLeft() {
  return editViewer.rotate(-90);
}

function rotateRight() {
  return editViewer.rotate(90);
}

async function saveAsPdf(indicies, settings) {
  if (editViewer.currentDocument) {
    if (indicies) {
      if (settings) {
        return await editViewer.currentDocument.saveToPdf(indicies, settings);
      }
      else {
        return await editViewer.currentDocument.saveToPdf(indicies);
      }
    }
    return await editViewer.currentDocument.saveToPdf();
  }
  else {
    return {code:-80304, message:"no document opened"};
  }
}

window.addEventListener('beforeunload', (event) => {
  event.preventDefault();
  event.returnValue = '';
});

async function clearAnnotations() {
  let currentDoc = editViewer.currentDocument;
  if (!currentDoc) {
    alert("Please load a document first.");
    return;
  }

  let currentPageId = currentDoc.pages[editViewer.getCurrentPageIndex()];
  let annotations = Dynamsoft.DDV.annotationManager.getAnnotationsByPage(currentPageId);

  if (annotations.length > 0) {
    for (let i = 0; i < annotations.length; i++) {
      // https://www.dynamsoft.com/document-viewer/docs/api/class/annotationmanager.html#deleteannotations

      if (!annotations[i].flattened && annotations[i].name !== 'barcode') {
        await Dynamsoft.DDV.annotationManager.deleteAnnotations([annotations[i].uid]);
      }
    }
  }
}
</script>
</html>
